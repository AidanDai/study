{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","structure":"mind_right","title":"EAMCScript5","root":true,"theme":"theme3","children":[{"id":"156bc67b82079447","title":"创建对象","parent":"root","children":[{"id":"156bc67d0bd4627","title":"工厂模式","parent":"156bc67b82079447","children":[],"note":"```JavaScript\n/**\n * 创建对象 - 工厂模式\n * @param  string \tname  \t姓名\n * @param  array \thobby \t爱好\n * @return object \to       创建的对象\n */\nfunction createPerson(name, hobby){\n\tvar o = new Object();\n\n\to.name = name;\n\to.hobby = hobby;\n\to.sayName = function(){\n\t\tconsole.log(this.name);\n\t}\n\n\treturn o;\n}\n\nvar person = createPerson(\"Aidan\", [\"code\", \"NBA\", \"read\"]);\n```\n\n返回的对象与构造函数或者与构造函数的原型属性之间没有关系，为此，不能依赖 instanceof 操作符来确定对象类型"},{"id":"156bc67d526aff68","title":"构造函数模式","parent":"156bc67b82079447","children":[{"id":"156bc6a72f44c129","title":"new","parent":"156bc67d526aff68","children":[],"note":"- 创建一个对象\n- 将this绑定到这个对象\n- 执行构造函数中的代码\n- 返回新对象"}],"note":"- 基本实现\n\n```JavaScript\n/**\n * 创建对象 - 构造函数模式（基本实现）\n * @param  string \tname  \t姓名\n * @param  array \thobby \t爱好\n */\nfunction Person(name, hobby){\n\tthis.name = name;\n\tthis.hobby = hobby;\n\n\tthis.sayName = function(){\n\t\tconsole.log(this.name);\n\t}\n}\n\nvar person = new Person(\"Aidan\", [\"code\", \"NBA\", \"read\"]);\n```\n\nPerson 实例都包含着一个不同的 Function 实例（这会导致不同的作用域链和标示符解析；浪费内存）\n\n- 改进实现\n\n```JavaScript\n/**\n * 创建对象 - 构造函数模式（改良实现）\n * @param  string \tname  \t姓名\n * @param  array \thobby \t爱好\n */\nfunction Person(name, hobby){\n\tthis.name = name;\n\tthis.hobby = hobby;\n\n\tthis.sayName = sayName;\n}\n\nfunction sayName(){\n\tconsole.log(this.name);\n}\n\nvar person = new Person(\"Aidan\", [\"code\", \"NBA\", \"read\"]);\n```\n\n虽然解决了 Person 实例都包含着一个不同的 Function 实例（这会导致不同的作用域链和标示符解析；浪费内存）的问题；但是这样污染了全局作用域"},{"id":"156bc67d5dc0030","title":"原型模式","parent":"156bc67b82079447","children":[],"note":"- 基本实现\n\n```JavaScript\nfunction Person(){}\n\nPerson.prototype.name = \"Aidan\";\nPerson.prototype.hobby = [\"code\", \"NBA\", \"read\"];\nPerson.prototype.sayName = function(){\n\tconsole.log(this.name);\n};\n\nvar person = new Person();\n```\n\n- 简单实现\n\n```JavaScript\nfunction Person(){}\n\n\n// 对象字面量重写整个原型时，注意 constructor: Person\nPerson.prototype =  {\n\tconstructor: Person,\n\tname: \"Aidan\",\n\thobby: [\"code\", \"NBA\", \"read\"],\n\tsayName: function(){\n\t\tconsole.log(this.name);\n\t}\n}\n\nvar person = new Person();\n```\n\n- 优点\n  - 原型的动态性（动态添加原型属性，所有实例共享）\n\n- 缺点：\n  - 无法删除原型对象上的属性\n  - 所有实例共享原型对象的引用属性，牵一发而动全身\n"},{"id":"156bc67d69738922","title":"组合模式","parent":"156bc67b82079447","children":[],"note":"```JavaScript\nfunction Person(name, hobby){\n\tthis.name = name;\n\tthis.hobby = hobby;\n}\n\nPerson.prototype = {\n\tconstrcutor: Person,\n\tsayName: function(){\n\t\tconsole.log(this.name);\n\t}\n}\n\nvar person = new Person(\"Aidan\", [\"code\", \"NBA\", \"read\"]);\n```\n\n基本完美（最常见方式）"},{"id":"156bc67d7465bb35","title":"动态原型模式","parent":"156bc67b82079447","children":[],"note":"```JavaScript\nfunction Person(name, hobby){\n\tthis.name = name;\n\tthis.hobby = hobby;\n\n\tif(typeof this.sayName != \"function\"){\n\t\tPerson.prototype = {\n\t\t\tconstrcutor: Person,\n\t\t\tsayName: function(){\n\t\t\t\tconsole.log(this.name);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvar person = new Person(\"Aidan\", [\"code\", \"NBA\", \"read\"]);\n```\n\n只会在初次调用构造函数时初始化原型对象（减小构造函数消耗）"},{"id":"156bc67d90949228","title":"寄生构造函数模式","parent":"156bc67b82079447","children":[],"note":"```JavaScript\nfunction Person(name, hobby){\n\tvar o = new Object();\n\n\to.name = name;\n\to.hobby = hobby;\n\n\to.sayName = function(){\n\t\tconsole.log(this.name);\n\t}\n\n\treturn o;\n}\n\nvar person = new Person(\"Aidan\", [\"code\", \"NBA\", \"read\"]);\n```\n\n- 实现与工厂模式一样，只是用 new 创建实例（也就是把工厂方法当做构造函数）\n\n- 返回的对象与构造函数或者与构造函数的原型属性之间没有关系，为此，不能依赖 instanceof 操作符来确定对象类型"},{"id":"156bc68a25736221","title":"稳妥构造函数模式","parent":"156bc67b82079447","children":[],"note":"稳妥对象：没有公共属性，而且其方法也不引用 this\n\n```JavaScript\nfunction Person(name, hobby){\n\tvar o = new Object(),\n\t\tname = name,\n\t\thobby = hobby;\n\t\n\to.sayName = function(){\n\t\tconsole.log(name);\n\t}\n\n\treturn o;\n}\n\nvar person = Person(\"Aidan\", [\"code\", \"NBA\", \"read\"]);\n```\n\n- 稳妥构造函数提供一种安全性（不让别的对象访问自己的数据成员）\n\n- 当然也具有工厂模式类的通病：返回的对象与构造函数或者与构造函数的原型属性之间没有关系，为此，不能依赖 instanceof 操作符来确定对象类型"}]},{"id":"156bc7752e1e6289","title":"继承","parent":"root","children":[{"id":"156bc77e38480250","title":"原型链","parent":"156bc7752e1e6289","children":[],"note":"```JavaScript\nfunction Person(name, hobby){\n\tthis.name = name;\n\tthis.hobby = hobby;\n}\n\nPerson.prototype = {\n\tconstructor: Person,\n\tsayName: function(){\n\t\tconsole.log(this.name);\n\t}\n}\n\nfunction Student(){\n\tthis.job = \"study\";\n}\n\nStudent.prototype = new Person(\"Aidan\", [\"code\", \"NBA\", \"read\"]);\n\nStudent.prototype.constructor = Student;\nStudent.prototype.sayJob = function(){\n\tconsole.log(this.job);\n};\n```\n\n- 符合继承的思想，抽象出相同的属相和方法\n------------------------------------------------\n- 祖类中的引用属性问题\n- 祖类原型添加方法一定要放在子类原型实例化之前\n- 关于祖类构造函数传递参数的问题（影响所有实例，但我觉得这才正体现了继承的思想）\n- 注意修改子类原型不能使用对象字面量"},{"id":"156bc77e710cf580","title":"借用构造函数","parent":"156bc7752e1e6289","children":[],"note":"```JavaScript\nfunction Person(){\n\tthis.name = \"Aidan\";\n\tthis.hobby = [\"code\", \"NBA\", \"read\"];\n}\n\nPerson.prototype = {\n\tconstructor: Person,\n\tsayName: function(){\n\t\tconsole.log(this.name);\n\t}\n}\n\nfunction Student(){\n\tPerson.call(this);\n\tthis.job = \"study\";\n}\n\nStudent.prototype = {\n\tsayJob: function(){\n\t\tconsole.log(this.job);\n\t}\n}\n```\n\n- 函数复用无从谈起（Person.call(this) 无法波及原型上的方法）\n- 构造函数传参问题（祖类和子类必须传相同的参数）\n"},{"id":"156bc77e86e3d23","title":"组合继承","parent":"156bc7752e1e6289","children":[],"note":"```JavaScript\nfunction Person(name, hobby){\n\tthis.name = name;\n\tthis.hobby = hobby;\n}\n\nPerson.prototype = {\n\tconstructor: Person,\n\tsayName: function(){\n\t\tconsole.log(this.name);\n\t}\n}\n\nfunction Student(){\n\tPerson.call(this, name, hobby);\n\tthis.job = \"study\";\n}\n\nStudent.prototype = new Person(name, hobby);\n\nStudent.prototype.constructor = Student;\nStudent.prototype.sayJob = function(){\n\tconsole.log(this.job);\n};\n```\n\n- 构造函数传参问题（祖类和子类必须传相同的参数）\n- 子类的实例保留了一份父类的属性，原型还保留了父类的一份属性"},{"id":"156bc77e95a33620","title":"原型式继承","parent":"156bc7752e1e6289","children":[],"note":"```JavaScript\nfunction create(obj){\n\tfunction F(){};\n\tF.prototype = obj;\n\treturn new F();\n}\n```\n\n- 解决了继承中的引用类型属性问题"},{"id":"156bc77eaa1faa97","title":"寄生式继承","parent":"156bc7752e1e6289","children":[],"note":"```JavaScript\nfunction create(obj){\n\tfunction F(){};\n\tF.prototype = obj;\n\treturn new F();\n}\n\nfunction createAnother(obj){\n\tvar clone = create(obj);\n\tclone.sayHi = function(){\n\t\tconsole.log(\"hi\");\n\t};\n\n\treturn clone;\n}\n```\n\n- 解决了继承中的引用类型属性问题\n- 使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率"},{"id":"156bc78f9c022513","title":"寄生组合式继承","children":[],"parent":"156bc7752e1e6289","note":"```JavaScript\nfunction create(obj){\n\tfunction F(){};\n\tF.prototype = obj;\n\treturn new F();\n}\n\nfunction inheritPrototype(sub, supper){\n\tvar prototype = create(supper.prototype);// prototype.__proto__ = supper.prototype\n\tprototype.constructor = sub;\n\tsub.prototype = prototype;\n}\n\nfunction Person(){\n\tthis.name = \"Aidan\";\n\tthis.hobby = [\"code\", \"NBA\", \"read\"];\n}\n\nPerson.prototype = {\n\tconstructor: Person,\n\tsayName: function(){\n\t\tconsole.log(this.name);\n\t}\n}\n\nfunction Student(){\n\tPerson.call(this);\n\tthis.job = \"study\";\n}\n\ninheritPrototype(Student, Person);\n\nStudent.prototype.sayJob = function(){\n\tconsole.log(this.job);\n};\n```"}]},{"id":"156bcc6f0e12d817","title":"原始值（<span style=\"color: rgb(37, 37, 37); font-family: Roboto, arial, sans-serif; font-size: 18px;\">primitive value</span>）","parent":"root","children":[{"id":"156bcc7d49754632","title":"undefined","parent":"156bcc6f0e12d817","children":[]},{"id":"156bcc7f0b16fb43","title":"null","parent":"156bcc6f0e12d817","children":[]},{"id":"156bcc805298a454","title":"boolean","parent":"156bcc6f0e12d817","children":[]},{"id":"156bcc821e3ab766","title":"number","parent":"156bcc6f0e12d817","children":[]},{"id":"156bcc843b88f555","title":"string","parent":"156bcc6f0e12d817","children":[]}]},{"id":"156bcc8a4126af41","title":"对象（object）","parent":"root","children":[{"id":"156bcc921dbe1c88","title":"原生对象（native object）","parent":"156bcc8a4126af41","children":[{"id":"156bcc9734c81a50","title":"内置对象（built-in object）","children":[],"parent":"156bcc921dbe1c88","note":" 由 ECMAScript 实现提供，独立于宿主环境的对象，ECMAScript 程序开始执行时就存在。"}],"note":" ECMAScript 实现中，并非由宿主环境，而是完全由本规范定义其语义的对象。"},{"id":"156bcc926b141d25","title":"宿主对象（host object）","children":[],"parent":"156bcc8a4126af41","note":"由宿主环境提供的对象，用于完善 ECMAScript 执行环境。"}]}]}},"meta":{"id":"57bbdca5e4b094664aeb5127","member":"webAidan","exportTime":"2017-06-05 12:36:02","diagramInfo":{"category":"mind_right","title":"ECMAScript5","created":"2016-08-23 13:18:29","creator":"webAidan","modified":"2016-08-24 21:44:07"},"type":"ProcessOn Schema File","version":"1.0"}}